/**
 * MuskMeter Clone Logic - Real Data Version
 * Fetches data.json (generated by PowerShell script) and renders it.
 */

// Configuration
const CONFIG = {
    daysToShow: 180, // Extended history
    colors: {
        low: 'level-1',
        med: 'level-2',
        high: 'level-3',
        spam: 'level-4',
        zero: 'level-0'
    },
    // Turkey Time
    timeZone: 'Europe/Istanbul'
};

// Utils
const formatDate = (date) => {
    return new Intl.DateTimeFormat('en-US', { weekday: 'short', day: 'numeric', month: 'short', timeZone: CONFIG.timeZone }).format(date);
};
const getDayName = (date) => new Intl.DateTimeFormat('en-US', { weekday: 'short', timeZone: CONFIG.timeZone }).format(date);
const getDayNum = (date) => new Intl.DateTimeFormat('en-US', { day: 'numeric', timeZone: CONFIG.timeZone }).format(date);

async function loadData() {
    try {
        const response = await fetch('data.json');
        if (!response.ok) throw new Error('Failed to load data.json');
        const tweets = await response.json();
        return processTweets(tweets);
    } catch (e) {
        console.error("Error loading real data, falling back to empty:", e);
        return {};
    }
}

function processTweets(tweets) {
    // We need to aggregate tweets by Day -> Hour
    // Key format: YYYY-MM-DD
    const data = {};

    // Sort tweets by date descending? They usually come simplified. 
    // We just iterate and bucket them.

    tweets.forEach(t => {
        // Convert to Target Timezone Date
        // created_at is UTC ISO: "2025-12-19T..."
        const dateObj = new Date(t.created_at);

        // Get parts in Turkey Time
        const parts = new Intl.DateTimeFormat('en-US', {
            timeZone: CONFIG.timeZone,
            year: 'numeric', month: '2-digit', day: '2-digit',
            hour: 'numeric', hour12: false
        }).formatToParts(dateObj);

        const p = {};
        parts.forEach(({ type, value }) => p[type] = value);

        // Construct Key: YYYY-MM-DD
        const dateKey = `${p.year}-${p.month}-${p.day}`;
        const hour = parseInt(p.hour); // 0-23

        if (!data[dateKey]) data[dateKey] = {};
        if (!data[dateKey][hour]) data[dateKey][hour] = 0;

        data[dateKey][hour]++;

        // Note: Retweets/Replies logic
        // The API defaults include retweets unless excluded.
        // We are counting them as User requested.
        // Replies? User said "replies will not count".
        // In V2 API, replies have 'referenced_tweets' with type 'replied_to'.
        const isReply = t.referenced_tweets && t.referenced_tweets.some(r => r.type === 'replied_to');
        if (isReply) {
            data[dateKey][hour]--; // Revert count if it's a reply
        }
    });

    return data;
}

// Generate Date Range for Calendar (Last X Days)
function generateDateKeys(days) {
    const keys = [];
    const today = new Date();
    for (let i = 0; i < days; i++) {
        const d = new Date(today);
        d.setDate(today.getDate() - i);

        // Format to YYYY-MM-DD in TRT
        const parts = new Intl.DateTimeFormat('en-US', {
            timeZone: CONFIG.timeZone,
            year: 'numeric', month: '2-digit', day: '2-digit'
        }).formatToParts(d);
        const p = {};
        parts.forEach(({ type, value }) => p[type] = value);

        keys.push(`${p.year}-${p.month}-${p.day}`);
    }
    return keys.reverse(); // Oldest to Newest
}

// Rendering
async function renderApp() {
    const tweetData = await loadData();
    const calendarGrid = document.getElementById('calendar-grid');
    const weekHeader = document.getElementById('week-header');

    // Clear
    calendarGrid.innerHTML = '';
    weekHeader.innerHTML = '<div class="day-label"></div>';

    // Generate columns keys
    // Since we have real data, we might have gaps. 
    // Logic: Show last 7 days OR items in data? 
    // User asked "as far back as possible".
    // Let's generate keys for the range of dates we fetched or last 30 days default.
    // For now, let's stick to last 7-14 days for visual clarity or do dynamic.
    // Let's do last 14 days for good visibility of the 100 tweets fetched.
    const dateKeys = generateDateKeys(14);

    // 1. Render Headers
    dateKeys.forEach(dateStr => {
        // Create a date object from YYYY-MM-DD (treat as local/midnight to get correct day name)
        const d = new Date(dateStr);
        const dayName = new Intl.DateTimeFormat('en-US', { weekday: 'short' }).format(d);
        const dayNum = d.getDate(); // Approximate

        const headerCell = document.createElement('div');
        headerCell.className = 'day-label';
        headerCell.innerHTML = `
            ${dayName}
            <span class="date-sublabel">${dayNum}</span>
        `;
        weekHeader.appendChild(headerCell);
    });

    // 2. Render Rows (Hours)
    for (let h = 0; h < 24; h++) {
        const row = document.createElement('div');
        row.className = 'grid-row';

        const timeLabel = document.createElement('div');
        timeLabel.className = 'time-label';
        timeLabel.textContent = `${h.toString().padStart(2, '0')}:00`;
        row.appendChild(timeLabel);

        dateKeys.forEach(dateStr => {
            const count = (tweetData[dateStr] && tweetData[dateStr][h]) || 0;
            const cell = document.createElement('div');

            let colorClass = CONFIG.colors.zero;
            if (count > 0) colorClass = CONFIG.colors.low;
            if (count > 2) colorClass = CONFIG.colors.med;
            if (count > 5) colorClass = CONFIG.colors.high; // Adjusted scale for smaller sample

            cell.className = `grid-cell ${colorClass}`;
            cell.textContent = count > 0 ? count : '';
            cell.title = `${count} tweets on ${dateStr} @ ${h}:00`;
            row.appendChild(cell);
        });

        calendarGrid.appendChild(row);
    }

    // Update Stats
    document.getElementById('total-tweets').textContent = "100 (Fetch Limit)";
}

document.addEventListener('DOMContentLoaded', renderApp);
